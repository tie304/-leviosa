use syn::{
    GenericArgument, PathArguments, Type, TypePath,
};

pub fn is_field_type(ty: &Type, field_type: &str) -> bool {
    if let Type::Path(TypePath { path, .. }) = ty {
        if path.segments.len() == 1 {
            let segment = &path.segments[0];
            // Adjust the condition to match the name of your AutoGenerated struct
            if segment.ident == field_type {
                if let PathArguments::AngleBracketed(args) = &segment.arguments {
                    return args.args.len() == 1
                        && matches!(args.args.first(), Some(GenericArgument::Type(_)));
                }
            }
        }
    }
    false
}

pub fn extract_relation_generic_type<'a>(ty: &'a Type) -> Option<&'a Type> {
    if let Type::Path(TypePath { path, .. }) = ty {
        if path.segments.len() == 1 {
            let segment = &path.segments[0];
            // Check if the segment identifier is "Relation"
            if segment.ident == "Relation" {
                if let PathArguments::AngleBracketed(args) = &segment.arguments {
                    // Ensure there's exactly one generic argument and it's a Type
                    if args.args.len() == 1 {
                        if let Some(GenericArgument::Type(ty)) = args.args.first() {
                            // Successfully found the generic type `T` in `Relation<T>`
                            return Some(ty);
                        }
                    }
                }
            }
        }
    }
    // Return None if the type is not `Relation<T>` or on failure to extract `T`
    None
}

pub fn type_to_string_identifier(ty: &Type) -> Option<String> {
    if let Type::Path(TypePath { path, .. }) = ty {
        // Assuming a simple path with no generic parameters for the identifier.
        let segments = &path.segments;
        if segments.len() == 1 {
            let segment = &segments[0];
            return Some(segment.ident.to_string());
        }
    }
    None
}
